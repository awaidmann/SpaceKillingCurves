<!DOCTYPE html/>
<html>
<head>
  <title>Continuity - An Unbroken Thought</title>
</head>
<body>
  <div
    id="main"
    style="height:100%; width:100%; background-color:gray;"
    >
    <canvas id="line-canvas" style="border:1px solid black"></canvas>
  </div>

  <script src="https://d3js.org/d3-selection.v1.min.js"></script>
  <script src="https://d3js.org/d3-path.v1.min.js"></script>
  <script src="https://d3js.org/d3-shape.v1.min.js"></script>
  <script src="https://d3js.org/d3-color.v1.min.js"></script>
  <script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
  <script src="https://d3js.org/d3-ease.v1.min.js"></script>
  <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
  <script src="https://d3js.org/d3-selection.v1.min.js"></script>
  <script src="https://d3js.org/d3-timer.v1.min.js"></script>
  <script src="https://d3js.org/d3-transition.v1.min.js"></script>
  <script src="https://d3js.org/d3-drag.v1.min.js"></script>
  <script src="https://d3js.org/d3-zoom.v1.min.js"></script>
  <script>
    var prev = undefined
    var timer = undefined
    var lineData = []

    var transform = undefined

    var main = d3.select("div"),
        height = main.node().clientHeight,
        width = main.node().clientWidth

    var canvas = main.select("canvas")
      .attr("height", height)
      .attr("width", width)
    var ctx = canvas.node().getContext("2d")
    ctx.lineWidth = 2
    ctx.strokeStyle = "white"

    var line = d3.line().context(ctx)

    canvas.call(d3.zoom()
      .on("zoom", zoom)
      .on("end", end)
    )
    canvas.on("mousemove.draw", record)

    function zoom() {
      ctx.save()
      ctx.clearRect(0, 0, width, height)
      transform = d3.event.transform
      ctx.translate(d3.event.transform.x, d3.event.transform.y)
      ctx.scale(d3.event.transform.k, d3.event.transform.k)
      drawForTransform()
      ctx.restore()
    }

    function record(e) {
      if (d3.event.metaKey) {
        var curr = [d3.event.offsetX, d3.event.offsetY]
        if (prev) {
          draw(prev, curr)
          lineData.push(normalize(curr, transform))
        }
        prev = curr
      }
    }

    function draw(prevCoor, currCoor) {
      ctx.beginPath()
      ctx.moveTo(prevCoor[0], prevCoor[1])
      ctx.lineTo(currCoor[0], currCoor[1])
      ctx.stroke()
    }

    function drawForTransform() {
      ctx.beginPath()
      line(lineData)
      ctx.stroke()
    }

    function drawControlPoints(coors) {
      ctx.save()
      ctx.lineWidth = 1
      ctx.strokeStyle = "black"
      coors.forEach(c => drawControlPoint(c[0][0], c[0][1]))
      ctx.restore()
    }

    function drawControlPoint(x, y) {
      ctx.beginPath()
      ctx.arc(x, y, 2, 0, 2*Math.PI)
      ctx.stroke()
    }

    function drawCubicBezier(coors) {
      ctx.save()
      ctx.lineWidth = 2
      ctx.strokeStyle = "red"
      coors.forEach(c => {
        ctx.beginPath()
        ctx.moveTo(c[0][0], c[0][1])
        ctx.bezierCurveTo(c[2][0], c[2][1], c[3][0], c[3][1], c[1][0], c[1][1])
        ctx.stroke()
      })
      ctx.restore()
    }


    function normalize(coor, t) {
      return t ? [(coor[0] - t.x)/t.k, (coor[1] - t.y)/t.k] : coor
    }

    function invertNormalize(coor, t) {
      return t ? [(coor[0]*t.k + t.x), (coor[1]*t.k + t.y)] : coor
    }

    function end() {
      if (lineData.length) {
        prev = invertNormalize(lineData[lineData.length - 1], transform)
        var controlPoints = calculateControlPoints()
        drawControlPoints(controlPoints)
        drawCubicBezier(controlPoints)
      }
    }

    function calculateControlPoints() {
      var diffs = piecewiseDifferentiate(lineData).map((d, i) => [lineData[i], d[1]])

      console.log(diffs)

      var approxExtrema = []
      var lastDiff = [[], 0]
      for(var d of diffs) {
        if (Math.sign(lastDiff[1]) != Math.sign(d[1])) {
          approxExtrema.push([invertNormalize(d[0], transform), d[1]])
        }
        lastDiff = d
      }
      return cubicBezierControlPointsFromDataPoints(approxExtrema.map(x => x[0]))
    }

    function piecewiseDifferentiate(data) {
      return data.map((x, i, arr) => {
        var diff = 0
        var next = arr[i]
        if (arr[i+1] && arr[i-1]) {
          last = arr[i-1]
          next = arr[i+1]
          diff = (next[1]-last[1])/(next[0]-last[0])
        }
        return [i, diff]
      })
    }

    function cubicBezierControlPointsFromDataPoints(dataPoints) {
      // http://www.math.ucla.edu/~baker/149.1.02w/handouts/dd_splines.pdf

      if (dataPoints && dataPoints.length > 3) {
        var controlPoints = []

        var prevREF = [0, 0, 0]
        var prevCoor = [0, 0]
        // convert to row-echelon form
        for (var i = 1; i < dataPoints.length - 1; i++) {
          var coor = dataPoints[i]

          var interpolant,
              tempPrevREF
          var tempCoor = [6*coor[0], 6*coor[1]]

          if (i == 1) {
            interpolant = [0, 4, 1]
            tempCoor = [
              tempCoor[0] - dataPoints[0][0],
              tempCoor[1] - dataPoints[0][1]
            ]
          } else if (i == dataPoints.length - 2) {
            interpolant = [1, 4, 0]
            tempCoor = [
              tempCoor[0] - dataPoints[dataPoints.length - 1][0],
              tempCoor[1] - dataPoints[dataPoints.length - 1][1]
            ]
          } else {
            interpolant = [1, 4, 1]
          }

          tempCoor = [
            tempCoor[0] - prevCoor[0],
            tempCoor[1] - prevCoor[1]
          ]

          tempPrevREF = [
            interpolant[0] - prevREF[1],
            interpolant[1] - prevREF[2],
            interpolant[2]
          ]
          var factor = tempPrevREF[1]
          // shortcut, we know tempPrevREF[0] should always be 0, if not I fucked up somewhere
          tempPrevREF = [0, 1, tempPrevREF[2] / factor]
          tempCoor = [tempCoor[0] / factor, tempCoor[1] / factor]

          controlPoints[i-1] = [tempPrevREF, tempCoor]

          prevREF = tempPrevREF
          prevCoor = tempCoor
        }

        // convert to reduce row-echelon form
        for(var i = controlPoints.length - 2; i > -1; i--) {
          var factor = controlPoints[i][0][2]

          controlPoints[i] = [
            [0, 1, 0],
            [
              controlPoints[i][1][0] - factor*controlPoints[i+1][1][0],
              controlPoints[i][1][1] - factor*controlPoints[i+1][1][1]
            ]
          ]
        }
        // [[Si, Si+1, Bi, Bi+1], ...]
        var beziers = [[,dataPoints[0]]]
          .concat(controlPoints)
          .concat([[,dataPoints[dataPoints.length - 1]]])
          .map((x, i, data) => {
            if (i < dataPoints.length - 1) {
              var b = x[1]
              var bNext = data[i+1][1]
              var bLine = [b[0] - bNext[0], b[1] - bNext[1]]

              return [
                dataPoints[i],
                dataPoints[i+1],
                [b[0] - bLine[0]/3, b[1] - bLine[1]/3],
                [bNext[0] + bLine[0]/3, bNext[1] + bLine[1]/3]]
            } else {
              return []
            }
          })
        beziers.pop()
        return beziers
      } else {
        return dataPoints
      }
    }
  </script>
</body>
</html>
