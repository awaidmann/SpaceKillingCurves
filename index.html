<!DOCTYPE html/>
<html>
<head>
  <title>Continuity - An Unbroken Thought</title>
</head>
<body>
  <div
    id="main"
    style="height:100%; width:100%; background-color:gray;"
    >
    <canvas id="line-canvas" style="border:1px solid black"></canvas>
  </div>

  <script src="https://d3js.org/d3-selection.v1.min.js"></script>
  <script src="https://d3js.org/d3-path.v1.min.js"></script>
  <script src="https://d3js.org/d3-shape.v1.min.js"></script>
  <script src="https://d3js.org/d3-color.v1.min.js"></script>
  <script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
  <script src="https://d3js.org/d3-ease.v1.min.js"></script>
  <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
  <script src="https://d3js.org/d3-selection.v1.min.js"></script>
  <script src="https://d3js.org/d3-timer.v1.min.js"></script>
  <script src="https://d3js.org/d3-transition.v1.min.js"></script>
  <script src="https://d3js.org/d3-drag.v1.min.js"></script>
  <script src="https://d3js.org/d3-zoom.v1.min.js"></script>
  <script>
    var POINT_FILTER = 5
    var prev = undefined
    var timer = undefined
    var lineData = []

    var transform = undefined

    var main = d3.select("div"),
        height = main.node().clientHeight,
        width = main.node().clientWidth

    var canvas = main.select("canvas")
      .attr("height", height)
      .attr("width", width)
    var ctx = canvas.node().getContext("2d")
    ctx.lineWidth = 2
    ctx.strokeStyle = "white"

    var line = d3.line().context(ctx)

    canvas.call(d3.zoom()
      .on("zoom", zoom)
      .on("end", end)
    )
    canvas.on("mousemove.draw", record)

    function zoom() {
      ctx.save()
      ctx.clearRect(0, 0, width, height)
      transform = d3.event.transform
      ctx.translate(d3.event.transform.x, d3.event.transform.y)
      ctx.scale(d3.event.transform.k, d3.event.transform.k)
      drawForTransform()
      ctx.restore()
    }

    function record(e) {
      if (d3.event.metaKey) {
        var curr = { x: d3.event.offsetX, y: d3.event.offsetY }
        if (prev) {
          draw(prev, curr)
          lineData.push(normalize(curr, transform))
        }
        prev = curr
      }
    }

    function draw(prevCoor, currCoor) {
      ctx.beginPath()
      ctx.moveTo(prevCoor.x, prevCoor.y)
      ctx.lineTo(currCoor.x, currCoor.y)
      ctx.stroke()
    }

    function drawForTransform() {
      ctx.beginPath()
      line(lineData.map(p => [p.x, p.y]))
      ctx.stroke()
    }

    function drawControlPoints(beziers) {
      ctx.save()
      ctx.lineWidth = 1
      ctx.strokeStyle = "black"
      beziers.forEach(bezier =>
        drawControlPoint(bezier.s0.x, bezier.s0.y))
      ctx.restore()
    }

    function drawControlPoint(x, y) {
      ctx.beginPath()
      ctx.arc(x, y, 2, 0, 2*Math.PI)
      ctx.stroke()
    }

    function drawCubicBezier(beziers) {
      ctx.save()
      ctx.lineWidth = 2
      ctx.strokeStyle = "red"
      beziers.forEach(bezier => {
        ctx.beginPath()
        ctx.moveTo(bezier.s0.x, bezier.s0.y)
        ctx.bezierCurveTo(
          bezier.b0.x, bezier.b0.y,
          bezier.b1.x, bezier.b1.y,
          bezier.s1.x, bezier.s1.y
        )
        ctx.stroke()
      })
      ctx.restore()
    }


    function normalize(p, t) {
      return t ? { x: (p.x - t.x)/t.k, y: (p.y - t.y)/t.k } : p
    }

    function invertNormalize(p, t) {
      return t ? { x: (p.x*t.k + t.x), y: (p.y*t.k + t.y) } : p
    }

    function end() {
      if (lineData.length) {
        prev = invertNormalize(lineData[lineData.length - 1], transform)
        var controlPoints = calculateControlPoints()
        drawControlPoints(controlPoints)
        drawCubicBezier(controlPoints)
      }
    }

    function calculateControlPoints() {
      var controlPoints = lineData.filter((_, i) => !(i%POINT_FILTER) || i == (lineData.length - 1))

      return cubicBezierControlPointsFromDataPoints(controlPoints.map(x => invertNormalize(x, transform)))
    }


    function cubicBezierControlPointsFromDataPoints(dataPoints) {
      // http://www.math.ucla.edu/~baker/149.1.02w/handouts/dd_splines.pdf

      if (dataPoints && dataPoints.length > 3) {
        var controlPoints = []

        var prevREF = [0, 0, 0]
        var prevCoor = { x: 0, y: 0 }
        // convert to row-echelon form
        for (var i = 1; i < dataPoints.length - 1; i++) {
          var coor = dataPoints[i]

          var interpolant,
              tempPrevREF
          var tempCoor = { x: 6*coor.x, y: 6*coor.y }

          if (i == 1) {
            interpolant = [0, 4, 1]
            tempCoor = {
              x: tempCoor.x - dataPoints[0].x,
              y: tempCoor.y - dataPoints[0].y
            }
          } else if (i == dataPoints.length - 2) {
            interpolant = [1, 4, 0]
            tempCoor = {
              x: tempCoor.x - dataPoints[dataPoints.length - 1].x,
              y: tempCoor.y - dataPoints[dataPoints.length - 1].y
            }
          } else {
            interpolant = [1, 4, 1]
          }

          tempCoor = {
            x: tempCoor.x - prevCoor.x,
            y: tempCoor.y - prevCoor.y
          }

          tempPrevREF = [
            interpolant[0] - prevREF[1],
            interpolant[1] - prevREF[2],
            interpolant[2]
          ]
          var factor = tempPrevREF[1]
          // shortcut, we know tempPrevREF[0] should always be 0, if not I fucked up somewhere
          tempPrevREF = [0, 1, tempPrevREF[2] / factor]
          tempCoor = { x: tempCoor.x / factor, y: tempCoor.y / factor }

          controlPoints[i-1] = [tempPrevREF, tempCoor]

          prevREF = tempPrevREF
          prevCoor = tempCoor
        }

        // convert to reduce row-echelon form
        for(var i = controlPoints.length - 2; i > -1; i--) {
          var factor = controlPoints[i][0][2]

          controlPoints[i] = [
            [0, 1, 0],
            {
              x: controlPoints[i][1].x - factor*controlPoints[i+1][1].x,
              y: controlPoints[i][1].y - factor*controlPoints[i+1][1].y
            }
          ]
        }
        // [[Si, Si+1, Bi, Bi+1], ...]
        var beziers = [[,dataPoints[0]]]
          .concat(controlPoints)
          .concat([[,dataPoints[dataPoints.length - 1]]])
          .map((cp, i, data) => {
            if (i < dataPoints.length - 1) {
              var b = cp[1]
              var bNext = data[i+1][1]
              var bX = b.x - bNext.x
              var bY = b.y - bNext.y

              return {
                s0: dataPoints[i],
                s1: dataPoints[i+1],
                b0: { x: b.x - bX/3, y: b.y - bY/3 },
                b1: { x: bNext.x + bX/3, y: bNext.y + bY/3 }
              }
            } else {
              return {}
            }
          })
        beziers.pop()
        return beziers
      } else {
        return dataPoints
      }
    }
  </script>
</body>
</html>
