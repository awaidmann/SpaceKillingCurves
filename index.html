<!DOCTYPE html/>
<html>
<head>
  <title>Continuity - An Unbroken Thought</title>
</head>
<body>
  <div
    id="main"
    style="height:100%; width:100%; background-color:gray;"
    >
    <canvas id="line-canvas" style="border:1px solid black"></canvas>
  </div>

  <script src="https://d3js.org/d3-selection.v1.min.js"></script>
  <script src="https://d3js.org/d3-path.v1.min.js"></script>
  <script src="https://d3js.org/d3-shape.v1.min.js"></script>
  <script src="https://d3js.org/d3-color.v1.min.js"></script>
  <script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
  <script src="https://d3js.org/d3-ease.v1.min.js"></script>
  <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
  <script src="https://d3js.org/d3-selection.v1.min.js"></script>
  <script src="https://d3js.org/d3-timer.v1.min.js"></script>
  <script src="https://d3js.org/d3-transition.v1.min.js"></script>
  <script src="https://d3js.org/d3-drag.v1.min.js"></script>
  <script src="https://d3js.org/d3-zoom.v1.min.js"></script>
  <script>
    var POINT_FILTER = 5
    var prev = undefined
    var timer = undefined
    var lineData = []

    var transform = undefined

    var main = d3.select("div"),
        height = main.node().clientHeight,
        width = main.node().clientWidth

    var canvas = main.select("canvas")
      .attr("height", height)
      .attr("width", width)
    var ctx = canvas.node().getContext("2d")
    ctx.lineWidth = 2
    ctx.strokeStyle = "white"

    var line = d3.line().context(ctx)

    canvas.call(d3.zoom()
      .on("zoom", zoom)
      .on("end", end)
    )
    canvas.on("mousemove.draw", record)

    function zoom() {
      ctx.save()
      ctx.clearRect(0, 0, width, height)
      transform = d3.event.transform
      ctx.translate(d3.event.transform.x, d3.event.transform.y)
      ctx.scale(d3.event.transform.k, d3.event.transform.k)
      drawForTransform()
      ctx.restore()
    }

    function record(e) {
      if (d3.event.metaKey) {
        var curr = [d3.event.offsetX, d3.event.offsetY]
        if (prev) {
          draw(prev, curr)
          lineData.push(normalize(curr, transform))
        }
        prev = curr
      }
    }

    function draw(prevCoor, currCoor) {
      ctx.beginPath()
      ctx.moveTo(prevCoor[0], prevCoor[1])
      ctx.lineTo(currCoor[0], currCoor[1])
      ctx.stroke()
    }

    function drawForTransform() {
      ctx.beginPath()
      line(lineData)
      ctx.stroke()
    }

    function drawControlPoints(beziers) {
      ctx.save()
      ctx.lineWidth = 1
      ctx.strokeStyle = "black"
      beziers.forEach(bezier =>
        drawControlPoint(bezier.s0[0], bezier.s0[1]))
      ctx.restore()
    }

    function drawControlPoint(x, y) {
      ctx.beginPath()
      ctx.arc(x, y, 2, 0, 2*Math.PI)
      ctx.stroke()
    }

    function drawCubicBezier(beziers) {
      ctx.save()
      ctx.lineWidth = 2
      ctx.strokeStyle = "red"
      beziers.forEach(bezier => {
        ctx.beginPath()
        ctx.moveTo(bezier.s0[0], bezier.s0[1])
        ctx.bezierCurveTo(
          bezier.b0[0], bezier.b0[1],
          bezier.b1[0], bezier.b1[1],
          bezier.s1[0], bezier.s1[1]
        )
        ctx.stroke()
      })
      ctx.restore()
    }


    function normalize(coor, t) {
      return t ? [(coor[0] - t.x)/t.k, (coor[1] - t.y)/t.k] : coor
    }

    function invertNormalize(coor, t) {
      return t ? [(coor[0]*t.k + t.x), (coor[1]*t.k + t.y)] : coor
    }

    function end() {
      if (lineData.length) {
        prev = invertNormalize(lineData[lineData.length - 1], transform)
        var controlPoints = calculateControlPoints()
        drawControlPoints(controlPoints)
        drawCubicBezier(controlPoints)
      }
    }

    function calculateControlPoints() {
      var controlPoints = lineData.filter((_, i) => !(i%POINT_FILTER))

      return cubicBezierControlPointsFromDataPoints(controlPoints.map(x => invertNormalize(x, transform)))
    }


    function cubicBezierControlPointsFromDataPoints(dataPoints) {
      // http://www.math.ucla.edu/~baker/149.1.02w/handouts/dd_splines.pdf

      if (dataPoints && dataPoints.length > 3) {
        var controlPoints = []

        var prevREF = [0, 0, 0]
        var prevCoor = [0, 0]
        // convert to row-echelon form
        for (var i = 1; i < dataPoints.length - 1; i++) {
          var coor = dataPoints[i]

          var interpolant,
              tempPrevREF
          var tempCoor = [6*coor[0], 6*coor[1]]

          if (i == 1) {
            interpolant = [0, 4, 1]
            tempCoor = [
              tempCoor[0] - dataPoints[0][0],
              tempCoor[1] - dataPoints[0][1]
            ]
          } else if (i == dataPoints.length - 2) {
            interpolant = [1, 4, 0]
            tempCoor = [
              tempCoor[0] - dataPoints[dataPoints.length - 1][0],
              tempCoor[1] - dataPoints[dataPoints.length - 1][1]
            ]
          } else {
            interpolant = [1, 4, 1]
          }

          tempCoor = [
            tempCoor[0] - prevCoor[0],
            tempCoor[1] - prevCoor[1]
          ]

          tempPrevREF = [
            interpolant[0] - prevREF[1],
            interpolant[1] - prevREF[2],
            interpolant[2]
          ]
          var factor = tempPrevREF[1]
          // shortcut, we know tempPrevREF[0] should always be 0, if not I fucked up somewhere
          tempPrevREF = [0, 1, tempPrevREF[2] / factor]
          tempCoor = [tempCoor[0] / factor, tempCoor[1] / factor]

          controlPoints[i-1] = [tempPrevREF, tempCoor]

          prevREF = tempPrevREF
          prevCoor = tempCoor
        }

        // convert to reduce row-echelon form
        for(var i = controlPoints.length - 2; i > -1; i--) {
          var factor = controlPoints[i][0][2]

          controlPoints[i] = [
            [0, 1, 0],
            [
              controlPoints[i][1][0] - factor*controlPoints[i+1][1][0],
              controlPoints[i][1][1] - factor*controlPoints[i+1][1][1]
            ]
          ]
        }
        // [[Si, Si+1, Bi, Bi+1], ...]
        var beziers = [[,dataPoints[0]]]
          .concat(controlPoints)
          .concat([[,dataPoints[dataPoints.length - 1]]])
          .map((x, i, data) => {
            if (i < dataPoints.length - 1) {
              var b = x[1]
              var bNext = data[i+1][1]
              var bLine = [b[0] - bNext[0], b[1] - bNext[1]]

              return {
                s0: dataPoints[i],
                s1: dataPoints[i+1],
                b0: [b[0] - bLine[0]/3, b[1] - bLine[1]/3],
                b1: [bNext[0] + bLine[0]/3, bNext[1] + bLine[1]/3]
              }
            } else {
              return {}
            }
          })
        beziers.pop()
        return beziers
      } else {
        return dataPoints
      }
    }
  </script>
</body>
</html>
