<!DOCTYPE html/>
<html>
<head>
  <title>Continuity - An Unbroken Thought</title>
</head>
<body onload="init()" onresize="resize()">
  <div id="main" style="height:100%; width:100%">
    <canvas id="line-canvas" style="border:1px solid black; background-color:#dfdfdf;"></canvas>
  </div>

  <script src="./bezier.js"></script>
  <script src="./transform.js"></script>
  <script src="./dataSource.js"></script>

  <script src="https://d3js.org/d3-selection.v1.min.js"></script>
  <script src="https://d3js.org/d3-path.v1.min.js"></script>
  <script src="https://d3js.org/d3-shape.v1.min.js"></script>
  <script src="https://d3js.org/d3-color.v1.min.js"></script>
  <script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
  <script src="https://d3js.org/d3-ease.v1.min.js"></script>
  <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
  <script src="https://d3js.org/d3-selection.v1.min.js"></script>
  <script src="https://d3js.org/d3-timer.v1.min.js"></script>
  <script src="https://d3js.org/d3-transition.v1.min.js"></script>
  <script src="https://d3js.org/d3-drag.v1.min.js"></script>
  <script src="https://d3js.org/d3-zoom.v1.min.js"></script>
  <script>
    var POINT_FILTER = 5
    var currStroke = Promise.resolve([])
    var transform = Promise.resolve()
    var canvas,
      ctx,
      width = 0,
      height = 0

    function saveStroke(strokePromise) {
      return Promise.all([
          strokePromise
            .then(calculateControlPoints)
            .then(setNextStrokes),
          transform
        ]).then(res => {
          var strokes = res[0]
          draw(strokes, res[1])
          return [(strokes[strokes.length - 1] || {}).end || {}]
        })
    }

    function calculateControlPoints(dataPoints) {
      return dataPoints
        ? Bezier.cubicBezierControlPointsFromDataPoints(
          dataPoints.filter((_, i) => !(i%POINT_FILTER)
            || i == (dataPoints.length - 1)))
        : []
    }

    // Canvas/D3 drawing
    function draw(strokes, transform) {
      ctx.save()
      ctx.clearRect(0, 0, width, height)
      if (transform) {
        ctx.translate(transform.x, transform.y)
        ctx.scale(transform.k, transform.k)
      }

      drawCubicBezier(strokes)
      // drawControlPoints(strokes)

      ctx.restore()
    }

    function drawStrokePath(prevCoor, currCoor) {
      ctx.beginPath()
      ctx.moveTo(prevCoor.x, prevCoor.y)
      ctx.lineTo(currCoor.x, currCoor.y)
      ctx.stroke()
    }

    function drawControlPoints(beziers) {
      if (beziers) {
        ctx.save()
        ctx.lineWidth = 1
        ctx.strokeStyle = "black"
        beziers.forEach(bezier => drawControlPoint(bezier.start, 2))
        ctx.restore()
      }
    }

    function drawControlPoint(p, r) {
      if (p && r) {
        ctx.beginPath()
        ctx.arc(p.x, p.y, r, 0, 2*Math.PI)
        ctx.fill()
      }
    }

    function drawCubicBezier(beziers) {
      if (beziers && beziers.length) {
        ctx.save()
        ctx.lineWidth = 2
        ctx.strokeStyle = "red"
        ctx.fillStyle = "red"

        drawControlPoint((beziers[0] || {}).start, 4)

        beziers.forEach(bezier => {
          ctx.beginPath()
          ctx.moveTo(bezier.start.x, bezier.start.y)
          ctx.bezierCurveTo(
            bezier.cpA.x, bezier.cpA.y,
            bezier.cpB.x, bezier.cpB.y,
            bezier.end.x, bezier.end.y
          )
          ctx.stroke()
        })
        ctx.restore()
      }
    }


    // DOM Event handling
    function zoom() {
      transform = Promise.all([
        getStrokes(),
        Promise.resolve(d3.event)
      ]).then(res => {
        var transform = (res[1] || {}).transform
        draw(res[0], transform)
        return transform
      })

    }

    function record() {
      Promise.all([
        Promise.resolve({ x: d3.event.offsetX, y: d3.event.offsetY }),
        currStroke,
        transform
      ]).then(res => {
        var p = res[0]
        var stroke = res[1]
        var t = res[2]
        if (stroke && stroke.length) {
          drawStrokePath(invertNormalize(stroke[stroke.length - 1], t), p)
        }
        return stroke.push(normalize(p, t))
      })
    }

    function resize() {
      height = d3.select("#main").node().clientHeight
      width = d3.select("#main").node().clientWidth
      if (canvas) {
        canvas
          .attr("height", height)
          .attr("width", width)
      }

      if (ctx) {
        Promise.all([getStrokes(), transform])
          .then(res => draw.apply(null, res))
      }
    }

    function init() {
      canvas = d3.select("#line-canvas")
      resize()

      ctx = canvas.node().getContext("2d")
      setupDraw()

      d3.selection()
        .on("keydown", setupAltControls)
        .on("keyup", teardownAltControls)
    }

    // Event handler setup/teardown
    function setupAltControls() {
      if (d3.event.metaKey) {
        setupZoom()
        teardownDraw()
      }
    }

    function teardownAltControls() {
      if (d3.event.key === "Meta") {
        teardownZoom()
        setupDraw()
      }
    }

    function setupDraw() {
      canvas.on("mousedown", () => canvas.on("mousemove", record))
      canvas.on("mouseup", () => {
        canvas.on("mousemove", null)
        currStroke = saveStroke(currStroke)
      })
    }

    function teardownDraw() {
      canvas.on("mousedown", null)
      canvas.on("mousemove", null)
      canvas.on("mouseup", null)
    }

    function setupZoom() {
      canvas.call(d3.zoom().on("zoom", zoom))
    }

    function teardownZoom() {
      canvas.on(".zoom", null)
    }

  </script>
</body>
</html>
