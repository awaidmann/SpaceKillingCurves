<!DOCTYPE html/>
<html>
<head>
  <title>Continuity - An Unbroken Thought</title>
</head>
<body>
  <div
    id="main"
    style="height:100%; width:100%; background-color:gray;"
    >
    <canvas id="line-canvas" style="border:1px solid black"></canvas>
  </div>

  <script src="./bezier.js"></script>
  <script src="./transform.js"></script>
  <script src="./dataSource.js"></script>

  <script src="https://d3js.org/d3-selection.v1.min.js"></script>
  <script src="https://d3js.org/d3-path.v1.min.js"></script>
  <script src="https://d3js.org/d3-shape.v1.min.js"></script>
  <script src="https://d3js.org/d3-color.v1.min.js"></script>
  <script src="https://d3js.org/d3-dispatch.v1.min.js"></script>
  <script src="https://d3js.org/d3-ease.v1.min.js"></script>
  <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
  <script src="https://d3js.org/d3-selection.v1.min.js"></script>
  <script src="https://d3js.org/d3-timer.v1.min.js"></script>
  <script src="https://d3js.org/d3-transition.v1.min.js"></script>
  <script src="https://d3js.org/d3-drag.v1.min.js"></script>
  <script src="https://d3js.org/d3-zoom.v1.min.js"></script>
  <script>
    var POINT_FILTER = 5
    var prev = undefined
    var currStroke = Promise.resolve([])
    var transform = Promise.resolve()

    var main = d3.select("div"),
        height = main.node().clientHeight,
        width = main.node().clientWidth

    var canvas = main.select("canvas")
      .attr("height", height)
      .attr("width", width)
    var ctx = canvas.node().getContext("2d")
    ctx.lineWidth = 2
    ctx.strokeStyle = "white"

    var line = d3.line().context(ctx)

    d3.selection()
      .on("keydown", setupAltControls)
      .on("keyup", teardownAltControls)

    setupDraw()

    function saveStroke(strokePromise) {
      return Promise.all([
          strokePromise
            .then(calculateControlPoints)
            .then(setNextStrokes),
          transform
        ]).then(res => {
          var t = res[1]
          var strokes = res[0].map(b => {
            return {
              s0: invertNormalize(b.s0, t),
              s1: invertNormalize(b.s1, t),
              b0: invertNormalize(b.b0, t),
              b1: invertNormalize(b.b1, t)
            }
          })

          ctx.clearRect(0, 0, width, height)
          draw(strokes)
          return [normalize((strokes[strokes.length - 1] || {}).s1 || {}, t)]
        })
    }


    // Canvas/D3 drawing
    function draw(strokes) {
      // ctx.clearRect(0, 0, width, height)
      drawControlPoints(strokes)
      drawCubicBezier(strokes)
    }

    function drawStrokePath(prevCoor, currCoor) {
      ctx.beginPath()
      ctx.moveTo(prevCoor.x, prevCoor.y)
      ctx.lineTo(currCoor.x, currCoor.y)
      ctx.stroke()
    }

    function drawControlPoints(beziers) {
      if (beziers) {
        ctx.save()
        ctx.lineWidth = 1
        ctx.strokeStyle = "black"
        beziers.forEach(bezier =>
          drawControlPoint(bezier.s0.x, bezier.s0.y))
        ctx.restore()
      }
    }

    function drawControlPoint(x, y) {
      ctx.beginPath()
      ctx.arc(x, y, 2, 0, 2*Math.PI)
      ctx.stroke()
    }

    function drawCubicBezier(beziers) {
      if (beziers) {
        ctx.save()
        ctx.lineWidth = 2
        ctx.strokeStyle = "red"
        beziers.forEach(bezier => {
          ctx.beginPath()
          ctx.moveTo(bezier.s0.x, bezier.s0.y)
          ctx.bezierCurveTo(
            bezier.b0.x, bezier.b0.y,
            bezier.b1.x, bezier.b1.y,
            bezier.s1.x, bezier.s1.y
          )
          ctx.stroke()
        })
        ctx.restore()
      }
    }


    // DOM Event handling
    function zoom() {
      transform = Promise.all([
        getStrokes(),
        Promise.resolve(d3.event)
      ]).then(res => {
        var strokes = res[0]
        var e = res[1]

        ctx.save()
        ctx.clearRect(0, 0, width, height)
        ctx.translate(e.transform.x, e.transform.y)
        ctx.scale(e.transform.k, e.transform.k)
        draw(strokes)
        ctx.restore()

        return e.transform
      })

    }

    function record() {
      Promise.all([
        Promise.resolve({ x: d3.event.offsetX, y: d3.event.offsetY }),
        currStroke,
        transform
      ]).then(res => {
        var p = res[0]
        var stroke = res[1]
        var t = res[2]
        if (stroke && stroke.length) {
          drawStrokePath(invertNormalize(stroke[stroke.length - 1], t), p)
        }
        return stroke.push(normalize(p, t))
      })
    }


    // Event handler setup/teardown
    function setupAltControls() {
      if (d3.event.metaKey) {
        setupZoom()
        teardownDraw()
      }
    }

    function teardownAltControls() {
      if (d3.event.key === "Meta") {
        teardownZoom()
        setupDraw()
      }
    }

    function setupDraw() {
      canvas.on("mousedown", () => canvas.on("mousemove", record))
      canvas.on("mouseup", () => {
        canvas.on("mousemove", null)
        currStroke = saveStroke(currStroke)
      })
    }

    function teardownDraw() {
      canvas.on("mousedown", null)
      canvas.on("mousemove", null)
      canvas.on("mouseup", null)
    }

    function setupZoom() {
      canvas.call(d3.zoom().on("zoom", zoom))
    }

    function teardownZoom() {
      canvas.on(".zoom", null)
    }

  </script>
</body>
</html>
